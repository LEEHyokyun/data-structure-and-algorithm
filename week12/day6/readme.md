[day6]

[DFS + BFS 혼용 / 선별적/제한적 BFS]

- 감시피하기 : DFS + BFS
  - DFS는 맞는데, 2차원 배열 곧이 곧대로 DFS 하는 것이 아니라, 가능한 위치에 대해서만 "1차원 DFS" 하는 것이 핵심.
  - 조건 부합하는 dfs 진행 후, 2차원 배열 모두 순회하면서 teacher의 배치 위치에 대해서만 감시 피하기 결과가 성립하는지 판단하면 됨.
  - 또 하나의 핵심 : 감시 피하기 결과 성립 여부 확인 -> 단순 순회가 아닌, DFS 결과를 바탕으로 BFS하는 것.
    - 갈 수 있을 지점 끝까지 dx, dy 지속 진행
      - 다만 기존 bfs와는 달리, 경계조건 바깥일 경우 continue(다음 인접노드)가 아닌, break.
      - if(curx < 0 || cury < 0 || curx >= N || cury >= N) break;

- 거리두기 : 선별적 BFS 및 제한적 BFS
  - 응시자(P)를 대상으로 하는 BFS
  - P에 대해 BFS하다가(선별적 BFS)
    - 제한적 BFS 진행
      - 거리가 1 ~ 2 인 인접노드에 대해 파티션을 만나면 OK
      - 거리가 1 ~ 2 인 인접노드에 응시자가 또 존재하면 실패
      - 전 순회간 통과 시 1, 하나라도 조건 불만족 시 0
        - queue에 대해 반복순회를 하되, distance를 "경로"로 잡고, 경로가 3이상이면 탐색대상에서 제외
        - 나머지 인접노드들에 대해 맨해튼 거리 부합 여부 및 파티션(파티션은 그냥 통과/적합 기준은 아님)를 판별
        - 모든 순회를 통과하였을경우에만 true 리턴

[1차원 DFS]

- 핵심은 2차원 DFS를 1차원 DFS로 바꾸는 것.
  - 체스의 경우 어차피 하나의 행에 1개의 체스 가능하여, index = 행, col[index] = 체스 배치 열로 둔다.
  - 이 col에 대해 경우의 수를 나누기 위해 DFS.
- 본 케이스의 경우, 장애물을 둘 수 있는 곳은 arrayList를 활용하여 list에 둔다.
  - 이 list를 바탕으로 1차원 DFS를 진행한다.

[DFS vs BFS]
- 기본적으로 최단경로, 최소경로 -> BFS
  - 모든 "경우의 수"를 구해야 한다 -> DFS -> 만약 원소 개수가 10만개? DP