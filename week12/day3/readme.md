[day3]

[구현/Reverse DP/]

- A to B
  - 역방향 DP : B -> A
  - 1을 뗀다 -> 10으로 나눈 몫과 나머지를 활용한다.

- 연산 결정이 애매할 경우
  - 점화식을 통한 DP도 아님(원소크기 매우 크고, 분기 처리 자체가 애매)
    - %2, %3, -n -> 연산 선택의 기준?
    - 애매하면 BFS.
  - 모든 경우의 수를 돌고, "최단거리" = BFS.
  - 가능한 경우의 수 (전역관리) 가 아니다.
  - 독립적인 경로에 대한 카운팅 관리.
    - 전역적인 카운팅 변수의 관리가 아니라, 각 경로마다 카운팅 변수 관리가 필요함.
      - Queue에 int[] 하거나
      - Map을 활용하거나(Map<String, Integer>)
  - 최단거리와 동일한 의미
    - 매트릭스 -> 최단거리 누적 (graph[i][j] + cur)
    - 최초 도달 = 최단 경로를 보장한다.