## 1. Day6

[이동하면서 가장 빨리 만나는 최소시간(1차원 BFS)/인접주택탐색(2차원 BFS)]
- Implements : 배운점 
  - "움직일 수 있는 경로가 주어지고 최소한의 경로/인접 경로 탐색" -> BFS
    - 각 인접노드에 대한 정보를 모두 기록해야 하므로 if-if-if로 분기처리 >> BFS
    - 인접노드 중 단 하나의 인접노드만 방문할 수 있다면 if-elif-elif로 분기처리 >> DFS
  - [이동경로가 주어지고 최소경로 구하기]
    - 가장 빨리 만나는 최소시간의 알고리즘은 Dijkstra을 활용하였다.
      - 각 단계별은 인접노드로의 이동을 의미, 여기서 일치점을 찾는 것이 최단경로(최소시간)를 보장할 수 있다.
      - if(x-1 >=0 && visited[x-1] == false){ visited[x-1] = true; q.offer(x-1); }
      - 조건별로 이동하고 큐에 다음 이동경로를 넣고, 다음 순회에 이 인접노드를 빼면서 순회 반복.
  - [이동경로가 주어지고(dx/dy) 인접노드 탐색하기]
    - 인접노드를 모두 탐색하는 것도 BFS(Dijkstra)를 활용 가능하다.
      - 이동할 수 있는 경로를 정해주고 int[] dx = {-1, 1, 0, 0}; / int[] dy = {0, 0, -1, 1};
      - int nx = cx + dx[i];를 순회하면서 이동할 수 있는 모든 경로를 탐색할 수 있다.
      - 그 인접노드를 queue에 넣으면서 q.offer(new int[] {nx, ny}); 경로를 탐색해나간다.
- Improvements : 막혔던 지점 / 고민한 포인트
  - BFS의 본질
    - “시작점에서 인접한 모든 곳을 동일 거리 레벨로 확산 탐색”
    - 1차원 BFS : 숨바꼭질 (1697)
    - 2차원 BFS : 단지번호붙이기 (2667), 미로탐색 (2178)
    - 3차원 BFS : 토마토 (7569)
  - Queue 구현체는 LinkedList를 활용하자.
    - poll(), offer(item) 활용! (add, remove는 예외를 반환하는 차이) 
    - https://bezzang2.tistory.com/109
  - util 활용하기!
    - Collections.sort(houseCounts); --Collections API 이용하기
    - houseCounts.sort(Comparator.naturalOrder()); -만들어놓은 ArrayList 그 자체를 Comparator API를 삽입하여 정렬하기\
    - 받아온 값이 단일문자(charAt)일떄 이를 숫자로 변환할때, line.charAt(j) - '0';
- Additional : 추가적인 유의점들

[Details : BFS]

```sql
시작점 5
→ [4, 6, 10]  (거리 1)
→ [3, 5, 7, 9, 12, 20] (거리 2)
```

이런 식으로 가까운 노드들을 먼저 전부 탐색한 후 그 다음 단계로 넘어가기 때문에
(**다음 큐 = 각 노드에서 방문한 인접노드들의 그 다음 인접노드들이 순차적으로 저장)
--> 처음 k를 만나는 순간의 count가 곧 최단 거리를 보장할 수 있다.

[DFS/BFS 접근 관점]

| 상황                           | 코드 형태                      | 의미                           | 사용 예시                                                    |
| ---------------------------- | -------------------------- | ---------------------------- | -------------------------------------------------------- |
| **모든 인접 노드를 전부 탐색해야 하는 경우**  | `if`, `if`, `if`           | 각 조건이 **독립적**이므로 모두 검사해야 함   | 미로 탐색, 최단 거리 탐색, 숨바꼭질(1697번)                             |
| **인접 노드 중 단 하나만 이동해야 하는 경우** | `if`, `else if`, `else if` | 한 가지 경우만 선택해야 함 → **분기형 탐색** | DFS의 특정 조건 분기, 탐욕적 선택 기반의 경로(예: 방향성 그래프에서 1가지 길만 가야 할 때) |

[유형]

| BFS 문제 유형                  | 분기 형태                      | 이유          |
| -------------------------- | -------------------------- | ----------- |
| 그래프/미로/경로 찾기 (인접 노드 모두 방문) | `if`, `if`, `if`           | 모든 방향 탐색    |
| 한 방향만 의미가 있는 문제 (탐욕/결정 문제) | `if`, `else if`, `else if` | 조건 중 하나만 선택 |
