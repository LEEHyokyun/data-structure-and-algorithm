## 1. Day5

[계단을 오르면서 누적할 수 있는 값 중 최대값(DP)/1로 만드는 연산의 최소값(DP)]
- Implements : 배운점 
  - DP "사고과정"
    - DP를 이용하는 문제/키워드.
    - 점화식을 도출하기 위해 몇번의 예시를 만드는 과정이 필요할 듯하다.
  - main / static 함수호출과 마찬가지로 클래스 밖의 전역변수를 사용한다면, 이 변수도 "static"해야 한다.
- Improvements : 막혔던 지점 / 고민한 포인트
  - "총 점수의 최댓값"이라는 문제를 보고 모든 경우를 더한 후에 그 중 큰 값을 고르면 되는지, 애초에 큰 값을 도출하기 위한 경로가 정해져 있는 것인지(탐욕) 궁금하였다.
    - 모든 가능한 최적 경로를 고려해서 그 중 최댓값을 누적하는 구조로 "탐욕"은 아니다.
  - DP의 기저조건 구성
    - 기저조건을 반드시 구성해야하며, 구성하지 못한다면 stackOverFlow 발생(반복순회로 인한 callstack 메모리 부족)
    - JVM의 구조적 한계(call stack 1개의 크기가 보통 1MB~2MB)로 인해 300 call stack만 누적하더라도 overflow 오류 발생.
    - 따라서 Java는 구조적으로 취약하므로 반드시 tabulation을 사용한다(C++처럼 스택최적화 및 Python처럼 tail recursion 지원 불가).
- Additional : 추가적인 유의점들
  - 브루트포스
    - 모든 경우를 더한 후에 그 중 큰 값 = 완전탐색
  - DP
    - 진행경로가 top down(재귀적 상향) .. memoization/메모리 오류 가능성
    - 진행경로가 bottom top .. tabulation/결과를 기록해나가며/가장 안정적
    
[DP 사고과정]
- 탐욕은 "당장 눈앞의 최선 선택”, DP는 “모든 하위 경우의 최적 결과를 비교한 최선 선택”
- 10번째 계단의 최대 점수는 9번째와 8번째 계단의 최대 점수에 의존한다.
- 마지막 계단을 오르는 경우의 수는 두가지 경우만 존재한다.
  - 이전이전 계단을 밟은 상태에서 마지막 계단을 밟는 경우
  - 이전이전이전 계단을 밟고, 이전 계단을 밝고 마지막 계단을 밟는 경우
  - 이 두가지 경우 중, 어차피 마지막 계단은 무조건 밟으므로 "이전이전/이전이전이전 + 이전"의 최대값을 선택한다.

[DP의 신호]

| DP의 신호            | 예시 문구                                  |
| ----------------- | -------------------------------------- |
| 최댓값 / 최솟값 / 최소 비용 | “최대 점수”, “최소 시간”, “최소 비용”              |
| 연속적 선택 / 단계적 누적   | “N번째까지 도달”, “이전 결과를 바탕으로”              |
| 중복되는 계산           | “이전 단계의 결과를 이용”, “한 번 계산한 것을 다시 사용 가능” |
