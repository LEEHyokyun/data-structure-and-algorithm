[day5]

- 과자
  - 이분탐색
    - 이분탐색의 핵심은 조건에 따라 min을 mid + 1, max를 mid - 1로 조정해가면서 최종 해를 추출해나가는 것.
    - min = least, max = most, mid = (min + max) / 2, 그리고 while(min <= max)
    - > 중요한 것은, mid값은 범위를 줄여가기 위한 "매개체"일 뿐이라는 것.
      - 등호의 의미? 조건을 만족하는 상황을 계속 만들어내다가, 보통은 "특정 지점"(점의 순간)이 될때 끝난다.
        > - mid를 바라보는 것은 잘못된 관점. 그 "이전에서의" max, min이 어떤 메커니즘으로 어떻게 변화하는지가 더 중요. 
      - while min <= max 에서 등호의 의미? 일반적으로는 min = max 인 상황에서 해당 해를 범위가 "특정된다"
      - 그리고 min -> 최소값, max -> 최대값, 이에 대한 두 값을 기준으로 "이분탐색의 기준인" mid 값
        - 여기까진 OK.
        - 과자의 길이를 mid값으로 설정하였을때, M명에게 나눠줄 수 있다.
          - "문제에서 요구하는 최대의 값은 아니다"

- 예산
  - 예산이 적은 부서부터 차례로 지원해주면 된다.
  - 전형적인 그리디.
    - 동전문제와 비슷한 양상

[이분탐색의 해 도출 과정]

- 이분탐색을 진행할때, mid값은 다음 단계를 위한 "중간매개체"일 뿐이다.

| min | max | mid | count | 결과 |
| --- | --- | --- | ----- |----|
| 1   | 10  | 5   | 2     | X  |
| 1   | 4   | 2   | 5     | OK |
| 3   | 4   | 3   | 3     | OK |
| 4   | 4   | 4   | 2     | X  |

mid는 마지막으로 검사한 값일 뿐이다. 실패한 값일 수도 있고, 심지어 최적해보다 클 수도 있다.

```java
if (count >= M)
    min = mid + 1;  // mid는 가능 → 더 큰 쪽 탐색
else
    max = mid - 1;  // mid는 불가능 → 더 작은 쪽 탐색
```

이분탐색의 "판별식"이라 할 수 있는 조건분기는
- count >= M 조건을 만족한다? = 해당 max 값 = 조건을 만족하는 최대 값 유지 = min 값만 증가
- count < M 조건 불만족한다? = 불가능해지는 "첫"지점 혹은 "마지막"지점으로, 이후 가능한 지점을 탐색하거나 탐색 종료
  - 이때 max를 다시 원복하는 느낌임.

> 중요한 점, 조건을 만족하는 "max"는 항상 조건을 만족하는 "최대의 해"이다.

이러한 이분탐색의 특성상,

> 끝까지 모든 조건을 만족하지 못한다면, min = 1이 고정되어있으므로, max = 0이 된다.

즉, 조건을 만족하는 "최대 길이" = max = 조건을 만족하지 못한다면 자연스럽게 0

[최적의 해가 mid ? 경계값 ?]

핵심 분리 요소는, mid를 해로 사용하는가, 조건을 만족하는 판별식으로 사용하는가.

- 지금처럼 판별식 사용

```java
mid는 가능/불가능만 판정
```

-> "최대의 해"는 결국 max

- 특정 배열에서 이분탐색을 통해, "해당 해"를 직접 찾거나 target을 탐색하는 경우
- 즉, mid가 탐색하고자 하는 그 값 자체일때. 
- mid를 조건으로 사용하지 않고 해와 일치하는지 동등여부.

-> 해 그 자체, mid.