## 1. Day1

[DFS]

- "경우의 수"
  - 열에 아홉은 "DP"
  - 점화식 도출
    - 역방향으로 생각하는게 좋다.
    - i,0 -> i행에 0열에 위치할때의 경우의수
    - i,1 -> i행에 1열에 위치할때의 경우의수
    - i,2 -> i행에 아무것도 위치하지 않았을때의 경우의수
      - i행에 채워야한다면
        - i,0 -> i-1,1 + i-1,2
        - i,1 -> i-1,0 + i-1,2
      - i행에 채우지 않아도 된다면 
        - i,2 -> i-1행에 1열, i-1행에 2열, i-1행에 아무것도 없을 경우의 수에 누적하면 됨
  - new int[N][M] / new long[N][M] -> N,M 무조건 int type.

- 멀리뛰기
  - 특수 경우에 대한(early return) 결과 도출은 순회를 하기 전에 main에서 아예 결과를 도출한다.
  - 결과 도출 후 순회

```java
if(n == 1) return 1 % MOD;
        if(n == 2) return 2 % MOD;
        
        //dp[1] => 1칸에 도달할 수 있는 경우의 수
        dp = new long[n+1];
        long answer = tabul(dp, n);
```

[유의사항]

- mod 적용 시

> 최종 도출에만 적용하는 것이 아닌, 매 연산마다 적용해야 한다.

- 점화식의 상태/조건/양상 파악이 중요하다.
  - i번째 행의 경우의 수는 "해당 우리"에 사자를 넣었을때, 안넣었을때의 경우의 수.

- length / n 조건 및 순회크기 등을 고려해서 특수상황에 대해 return 조건 정립하기

```java
if(n == 1) return dp[1] % MOD;
        if(n == 2) return dp[2] % MOD;
        
        for(int i = 3 ; i <= n ; i++){
            dp[i] = dp[i-1] % MOD + dp[i-2] % MOD;
        }
```