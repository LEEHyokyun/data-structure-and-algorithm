## day6.

[Brute Force/우선순위큐]
- Implements : 배운점
  - Brute Force(완전탐색)
    - 시행할 수 있는 모든 경우의 수에 대해 특정 조건부합 여부 및 분기처리 등을 수행한다.
  - DFS/BFS는 "인접노드" "경로"의 성격을 지니고, 브루트포스는 "가능한 경우"의 성격을 지닌다.
  - 이때 "가능한 모든 경우"와 "다음 경로에 대한 최적의 과정을 적용하고 이를 모든 단계에 적용하는 것은" 엄연히 다르므로 반드시 구별한다.
    - 다음 과정에 대한 최적의 과정을 일괄적으로 적용하는 것은 "Greedy".
  - PriorityQueue(우선순위 큐)
    - Type = 우선순위의 기준, 기준대로 정렬
  - 배열/정렬을 이용하면 가장 작은 두 요소를 빼올때마다 배열이 달라지므로 for 순회 의미없음.
    - 단계수행때마다 요소가 달라진다? 배열을 이용한 풀이는 아니다.
    - 이러면 Queue, Stack 등의 자료구조를 고려해본다.
    - 그런데 작은수 등 기준이 명확하다? 우선순위 큐.
- Improvements : 막혔던 지점 / 고민한 포인트
  - 약수탐색 시 순회조건은 제곱근 보다 크거나 같을때까지.
    - 약수는 항상 어느 한쪽은 제곱근보다 크거나 작다.
  - ArrayList의 사용?
    - array.get / array.size() / array.remove() / array.add()
      - String -> length()
      - String / int[] String[] -> length
    - array.sort(Comparator.naturalOrder());
  - 경계조건과 마지막 처리까지 완벽하게 연습할 것
    -  //2개 남을때까지
       while(pq.size() > 1)
    - 그렇다면 최악의 경우에는 1개만 남고, 이 1개도 확인필요
      - answer = pq.poll() >= K? answer++ : -1;
- Additional : 추가적인 유의점들

[Arrays.sort / Arrays.fill 등의 util]

int[] arr = {5, 3, 2, 4, 1};

// 오름차순 정렬
Arrays.sort(arr);

// 내림차순 정렬 (Integer 배열)
Integer[] nums = {5,3,2,4,1};
Arrays.sort(nums, Comparator.reverseOrder());

// 배열 초기화
int[] zeroArr = new int[5];
Arrays.fill(zeroArr, 0);

// 배열 복사
int[] subArr = Arrays.copyOfRange(arr, 1, 4); // arr[1], arr[2], arr[3]

// 스트림 활용
int[] distinctSorted = Arrays.stream(arr)
.distinct()
.sorted()
.toArray();

// 정렬 + 탐색
Arrays.sort(arr);
int idx = Arrays.binarySearch(arr, key);

// 중복제거
int[] distinct = Arrays.stream(arr).distinct().toArray();

// 부분배열처리
int[] sub = Arrays.copyOfRange(arr, start, end);

// 배열 초기화
Arrays.fill(arr, 0);

// 배열 커스텀 정렬
Arrays.sort(arr, Comparator.comparingInt(a -> a.someField));

[Stack/Queue/PriorityQueue]

| 자료구조                   | 대표 구현체                    | 특징                           | 자주 쓰는 DSL API      | 설명                              |
| ---------------------- | ------------------------- | ---------------------------- | ------------------ | ------------------------------- |
| **Stack**              | `java.util.Stack`         | LIFO (Last-In-First-Out)     | `push(E item)`     | 스택 맨 위에 요소 추가                   |
|                        |                           |                              | `pop()`            | 스택 맨 위 요소 제거 후 반환               |
|                        |                           |                              | `peek()`           | 스택 맨 위 요소 확인 (제거 X)             |
|                        |                           |                              | `isEmpty()`        | 스택이 비었는지 확인                     |
|                        |                           |                              | `search(Object o)` | 요소 위치 확인 (1-based)              |
| **Queue**              | `java.util.LinkedList`    | FIFO (First-In-First-Out)    | `offer(E e)`       | 큐에 요소 추가 (추가 불가 시 false)        |
|                        |                           |                              | `add(E e)`         | 큐에 요소 추가 (예외 발생 가능)             |
|                        |                           |                              | `poll()`           | 큐 맨 앞 요소 제거 후 반환, 없으면 null      |
|                        |                           |                              | `remove()`         | 큐 맨 앞 요소 제거 후 반환, 없으면 예외        |
|                        |                           |                              | `peek()`           | 큐 맨 앞 요소 확인, 없으면 null           |
|                        |                           |                              | `element()`        | 큐 맨 앞 요소 확인, 없으면 예외             |
| **PriorityQueue (PQ)** | `java.util.PriorityQueue` | 최소 힙 (기본) / Comparator 지정 가능 | `offer(E e)`       | 요소 추가                           |
|                        |                           |                              | `add(E e)`         | 요소 추가                           |
|                        |                           |                              | `poll()`           | 우선순위 가장 높은 요소 제거 후 반환           |
|                        |                           |                              | `peek()`           | 우선순위 가장 높은 요소 확인                |
|                        |                           |                              | `remove(Object o)` | 특정 요소 제거                        |
|                        |                           |                              | `size()`           | 현재 요소 개수                        |
|                        |                           |                              | `isEmpty()`        | 비었는지 확인                         |
|                        |                           |                              | `comparator()`     | 현재 Comparator 확인 (null → 자연 정렬) |


[완전탐색/DFS/BFS/Greedy]

| 알고리즘                   | 대표 문제 유형                                                               | 핵심 키워드                                | 언제 쓰는가? (구별 포인트)                                              | 장점                                 | 단점                               |
| ---------------------- | ---------------------------------------------------------------------- | ------------------------------------- | ------------------------------------------------------------- | ---------------------------------- | -------------------------------- |
| **완전탐색 (Brute Force)** | - 모든 조합<br>- 모든 순열/부분집합<br>- 전수 조사                                     | “모든 경우 다 해본다”<br>“경우의 수가 작다”          | - 경우의 수가 ≤ 10⁶ 수준<br>- 규칙성 없음<br>- 빠른 정답 도출보다 전체 탐색이 우선일 때    | - 구현 쉬움<br>- 실수 적음                 | - 비효율적<br>- N 커지면 시간 초과          |
| **DFS (깊이 우선 탐색)**     | - 트리 구조<br>- 그래프 경로 탐색<br>- 백트래킹<br>- 조합/부분집합 생성<br>- 순열 생성            | “깊게 파고든다”<br>“백트래킹”<br>“스택/재귀”        | - **경로 찾기** 문제<br>- **모든 경우 + 가지치기** 필요<br>- 재귀/스택 기반 탐색      | - 모든 경우 탐색 가능<br>- 백트래킹과 궁합 좋음     | - 깊은 재귀에서 스택 오버플로우 가능            |
| **BFS (너비 우선 탐색)**     | - 최단거리 (가중치 0 또는 1)<br>- 레벨 단위 탐색<br>- 퍼지는 형태(전염/확산)<br>- 그래프 최소 이동 횟수 | “최단거리 보장”<br>“레벨별”<br>“Queue”         | - **최단 거리** 문제 나오면 거의 100% BFS<br>- “N번 이동”처럼 층(Level)이 중요할 때 | - 최단거리 자동 보장<br>- 구현 단순            | - 메모리 많이 먹음<br>- 그래프 크면 queue 폭발 |
| **Greedy (탐욕법)**       | - 정렬 기반 최적 선택<br>- 최소 동전 수<br>- 회의실 배정<br>- 최소 비용 연결                   | “지금 당장 최선”<br>“정렬 → 순차 선택”<br>“국지 최적” | - **정렬하고 하나씩 선택**하는 구조면 의심<br>- “가장 작은/가장 큰 것부터”              | - 빠름, 구현 쉬움<br>- 시간이 거의 O(N log N) | - 항상 정답을 보장하지 않음<br>- 증명이 필요함    |

🔍 알고리즘 선택 기준: 문제를 보면 바로 떠올리기
1) 완전탐색이 떠오르는 경우

“가능한 모든 경우”가 필요

N이 작다 (N ≤ 15 ~ 20)

규칙성보다 전체 탐색이 명확

키워드: 모든 조합, 순열, 부분집합, brute force, 경우의 수

2) DFS가 떠오르는 경우

그래프에서 특정 경로를 찾고 싶다

백트래킹이 필요하다 (가지치기)

“깊이”가 중요하다

키워드: 재귀, 깊게, 백트래킹, 경로 찾기, 조합 생성

3) BFS가 떠오르는 경우 (가장 명확함)

최단 거리 문제 나왔다 → BFS 90%

이동 횟수(steps)가 필요하다

하나의 상태에서 파생되는 여러 상태가 퍼지는 구조

키워드: 최단거리, 최소 이동, 레벨, queue

4) Greedy가 떠오르는 경우

정렬 후 하나씩 뽑는 구조

항상 “지금 최선”이 전체 최선이 되는 것이 보장됨

그리디라고 설명할 수 있는 명확한 이유가 있어야 함

키워드: 정렬, 최소비용, 가장 큰 것/작은 것부터, 회의실 배정, 동전

- 요약

최단거리 → 거의 항상 BFS

트리/그래프 깊이 탐색 + 백트래킹 → DFS

정렬 후 선택 → Greedy

경우의 수 작고 전부 확인 가능 → 완전탐색