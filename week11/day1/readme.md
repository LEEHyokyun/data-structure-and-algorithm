[day6]

[BFS/Floyd Warshall]

> 모든 노드의 다른 노드로의 모든 경로 ? 플로이드 와샬, 단 3중 반복문이기에 노드 개수가 100개 정도로 매우 제한적.
 
> 노드 개수가 조금만 커지더라도 플로이드 와샬은 적용 불가, 기본 접근 방법은 BFS로 기억하자. 

- KEY POINT : 단순히 1 person > 1 person의 최단거리가 아니라, 1 person을 시작으로 "모든 사람에 대한", 그러한 1 person 역시 "모든 사람에 대한"
  - 플로이드 와샬 기반의 BFS.
  - BFS or 플로이드 와샬(i -> j로 이동하는 최단경로를 2차원 배열로 표현)

> 최단거리이긴 한데, 단일 start이 N개, 단일 start에 대해 모든 요소까지의 최단거리를 모두 구해야 한다? -> BFS + int[] dist (*visited X)

> 모든 N개의 요소에 대해 순회를 하지 않더라도, 내부적으로 start를 시작으로 모든 요소에 대해 가지치기하는 최단 경로를 구해야 한다 -> BFS + int[] dist

- 케빈 베이컨 6단계
  - 전체 순회도 아니고, 인접노드로의 이동이다. = BFS
  - 최단거리 = BFS
    - 1) 모든 사람 (1 ~ N)에 대하여, 각 사람은 또다시 1~N명에 대한 케빈베이컨 연산을 진행해야 한다. 
    - 2) 모든 사람에 대해 각각 진행한 연산 결과를 result로 구하고, 이를 전체 사람에 대해 합산한다.
    - 3) 이 합산을 answer와 비교하여 그 결과가 더 적은 수라면 answer에 반영한다. 
    - 4) bfs는 평소대로, 다음의 인접 사람에 대해 bfs를 반복하는 방식으로 진행한다. 다음 인접사람을 방문하였다면 visited true, depth++을 해준다.
  - 의문사항
    - result, answer를 비교하고 이를 최소값으로 교체할때 result 최소값이 여러명이고, 여러명일경우에는 가장 작은 사람을 반환하는 효율적인 방법
    - depth++ 하는 로직이 부자연스러움, 굳이 또다른 변수 d를 선언해야하나하는 의문있음
  - start = 단일, 인접노드로 이동, BFS 1번의 시행으로 각각의 결과를 도출하기 위해선 int[] 와 같은 별도 저장소 필요!
  - 인접노드 관리 = 사람의 수 = 1 ~ N (1에 대한 인접노드들..크기는 N+1)
  - 어차피 가장 작은 "사람"을 반환, min처리할때마다 사람 그 자체를 반환해주면 됨.

[케빈 베이컨 6단계 고찰]

- 1 -> 3 -> ... 인접노드로 넘어가는 depth .. BFS는 맞다.
  - 그런데 이를 모든 사람에 대해 진행하지 않고 단일 start 지점에 대해 한번에 구하는 것이 핵심.
  - 그러면서 int[] dist로 관리하는 것
- BFS는 맞지만, start 지점은 항상 1개이다.
  - 즉, 2번 순회를 하지 않고, 순회를 하는 것도 말이 안됨, start = 1 ~ N까지 출발점은 항상 고정, 여기서 모든 인접노드에 대해 bfs를 진행하는 것.
  - start 일때 BFS 1번으로 start 사람에 대한 케빈베이컨 연산을 구하고, 이것을 N번 순회하여 최소값을 도출.
- 중요한 것은, start = i로 고정하고, start로부터 dist를 또다른 배열로 관리하는 것. 
  - 각 bfs할때 start지점은 단일, -1이 아니다? 1 -> X 이미 경로를 구한 것이다.
  - 경로가 안될 수 없기 때문에, 무조건 누적형태(dist[x] = dist[cur] + 1)
- visited를 이용할 필요가 없다.

[플로이드 와샬]

- 경유지가 따로 존재할때 이용하는게 좋을 듯

```java
for (int k = 1; k <= N; k++) {
    for (int i = 1; i <= N; i++) {
        for (int j = 1; j <= N; j++) {
            dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);
        }
    }
}
```

- 가장 긴 노드
  - 출발점이 단일 지점이고, 이 단일 지점에 대해 특정 지점이 아닌 모든 경로 계산..BFS로도 충분
  - 1-> 2 OK 2-> 1 안된다..그래서 방문여부를 반드시 확인해주는 것.
    - 다만 int[] dist로 visited 대신 활용.

- fw 적용 시
  - 1) dist 배열(paths) 초기화.. if i == j -> 0, else -> Integer.MAX_VALUE 일단 초기화
  - 2) 조건(edge)에 따른 거리 초기화
     - 단, 이 초기화는 반드시 2차원 배열일 수 밖에 없음, start가 각기 다르므로.
  - 3) 초기화한 paths 배열에 대해 flow 적용, 예를 들어 2,4 + 4,3 -> 2거리 OK, 그러나 최초 상태는 인접하지 않아 INF상태임.
- 문제의 경우 모든 start 경우를 살펴볼 필요 없이 start = 1로 고정

FW 핵심 점화식

```java
if(paths[i][j] > paths[i][k] + paths[k][j]){
                        paths[i][j] = paths[i][k] + paths[k][j];
                    }
```

만약 count가 안된다면 max 값을 Integer.MAX_VALUE가 아닌 적당히 작은 값으로 조정

INF = 100000 (간선개수보다 적당히 큰 값)

