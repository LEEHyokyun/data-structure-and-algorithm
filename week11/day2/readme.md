[day2]

[DFS]

- 동전
  - visited 의미 없음 -> 동전을 몇개라도 사용 가능하다.
  - 중요한 것은 동전의 재사용 여부
    - 던전은 int i = 0 .. 순서 상관없이 방문여부만 확인, 흐름 상으로는 동일 구성으로 보았음
      - visited true -> continue
    - 치킨은 int i = start .. 순서 상관있음, 방문했다면 다른 경로를 찾았음(다른 구성으로 보았음)
      - start = i -> start = i + 1(dfs - i+1)
    - 동전은 방문여부, 이런 것도 필요없고 "무제한 사용"
      - start -> i가 넘어가면 i 고려할 수 없음, start = i!
        - 여기서 의심해야 한다. 무제한 사용? DFS로는 시간초과이다.
  - "정해진 100~200개의 소수의 배열에서만" 제한적으로 사용하는게 DFS.
    - 배열의 크기가 소수이지만 무제한 방문을 허용한다? 무조건 DP.
    - DFS(start = i + 1)을 하면서 조정할 수 있겠지만, 대부분 시간 초과 날 것.
  - 핵심은 예를 들어, 10이 있다고 하자.
    - 10 = 9 + 1, 8 + 2, 5 +5 ..만들어질 수 있는 경우에 대하여 합산한 것과 동일
      - 멀리뛰기와 동일하다.
      - i - coins 경우를 모두 합 -> dp[i] += dp[i-coin]

- 최소 경로의 "개수"
  - 최소 경로가 아닌, 그 갯수.
    - NOT BFS
    - 조합 해 도출 방안 판단
      - DFS?
      - DP?
    - 최단경로, 인접노드 ? BFS 의심. 
    - 모든 경로 ? 플로이드 와샬
    - 최단 경로, 모든 경로, 중간에 장애물 ? DP
  - 핵심 키워드 : 갈 수 있는 방향, 경우의 수가 지정되어있음.
  - 점화식 조건 오류 바로잡기 -> 1,1일때만 1이다.
    - if ((i == 1 || j == 1) && !isInPuddles(i,j,puddles)) {
      dp[i][j] = 1;
      continue;
      }
  - 나머지 경우에 대해서는 반드시 점화식 적용해야한다.
    - 어느 한쪽이 1이라도 무조건 1이 아니다, 특히 맨 끝 점
    - 웅덩이가 반영되면 그대로 위 점들의 경우의 수는 모두 0으로 초기화됨
    - 결론은 1,1만 1 나머지는 점화식 적용
  - 그리고 MOD 적용 시,
    - 계산 도중
    - 계산 결과 모두 적용해야 한다.

[m * n]

- 가로 m * 세로 n .. 선언은 가로 열 수 * 세로 행 수
- int[n+1][m+1] or int[n][m]  .. 2차원 배열은 행(세로) 먼저
- 맨 끝 지점은 m,n 순서대로
- 2차원 배열의 접근은 반대로 세로 - 가로 .. n-1, m-1 or n,m

- 문제에서 주어진 웅덩이 좌표는 그림상 m, n -> 가로 m 세로 n
- 따라서 이를 좌표로 나타내면 n,m임