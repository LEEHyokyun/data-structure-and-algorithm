## 1. Day5

[부분증가수열 : DP]
- 증가하는 부분 수열
  - 요소의 개수가 1000개
    - 완전탐색? 순회를 1000개의 반복문? -> 불가 : 완전탐색X
    - 1~2번의 순회는 필요하고, 그 순서가  DP가능성
      - dp[i] -> dp[i]를 끝으로 증가하는 수열을 만들 수 있는 최대 길이.
        - 기준값(dp[i])에 대해 순회를 하면서(j = 0 ~ j < i), dp[i] 값 자체를 누적시킨다.
        - 이전 순회에 이미 그 이전값 보다 큰 것이 반영되어있기에, 순회를 지속하면 부분 증가 수열이 반영된다.

[최종적으로 합이 큰 수를 찾기 : DP]
- 합이 큰 수열 찾기
  - 기본적으로 끝까지 가야함, 각 depth 별 모든 합을 저장하는 dp배열이 필요
    - dp는 1차원이 아닌 2차원
    - 다만, dp의 합은 "정해져 있다" -> 각 depth에서 가져갈 수 있는 최대의 합을 모두 산출한 후 최대값 최종 산정.

[부분증가수열 점화식 핵심 요소]

```java
for(int i = 0 ; i < N ; i++){
            dp[i] = 1; //부분 연속 증가수열 불가 시 기본 길이는 1
            
            for(int j = 0 ; j < i ; j++){
                if(array[j] < array[i]){
                    dp[i] = Math.max(dp[i], dp[j]+1); //dp[j]는 이전값 순회를 반복하면서 만족할때마다 부분증가수열 + 이전의 부분증가에 이어진 부분증가 조건까지 만족
                }
            }
            
            length = Math.max(length, dp[i]);
        }
```

- dp[i] 점화식은
  - 기본적으로 다른 수열보다 길 경우 해당 요소를 기준으로 길이를 즉시 갱신
  - 갱신할때마다 이전의값들의 부분증가수열을 만족하기에, 결과 누적이 된 채로 진행됨