## 1. Day3

[DP]
- Notes
  - 브루트포스로는 불가능
    - RGB의 경우 각 집마다 3가지의 선택, N개의 집에 대해서는 3^N에 가깝게 커지므로 안됨
    - 삼각형 역시 높이가 커질수록 O(N^2)의 시간복잡도 가능
  - DP
    - 연속된 두 집은 같은 색 불가
    - “현재 집의 선택은 바로 이전 집의 선택에만 의존한다”
    - 또한 현재의 비용은 이전의 비용 선택에 영향을 받는다.
    - 비용 최소화
      - “i번째 집까지 칠했을 때의 최소 비용 상태만 기억하자”
      - "i,j 선택 -> 다음 선택은 i+1,j or i+1,j+1 만 가능"
        - 반대로 i,j로 올 수 있는 경우는 왼쪽 : i-1,j-1 오른쪽 : i-1, j
        - 왼쪽의 경로 및 오른쪽의 경로 중 큰 경로를 선택하면서, 최종적으로 끝까지 갔을때 가장 큰 값을 선택한다.

- DP의 핵심은 점화식 세우기
  - 현재의 선택은 이전의 선택에 영향을 받는다.

[RGB]
  - 각각의 집을 R,G,B로 칠하는 비용이 다르다.

> dp[i][c] = i번째 집까지 칠했을 때,
> i번째 집을 색 c로 칠한 경우의 최소 비용
    
```java
dp[i][R] = cost[i][R] + min(dp[i-1][G], dp[i-1][B]);
dp[i][G] = cost[i][G] + min(dp[i-1][R], dp[i-1][B]);
dp[i][B] = cost[i][B] + min(dp[i-1][R], dp[i-1][G]);
```

init 시(첫번째 집)

```java
dp[1][R] = cost[1][R]
dp[1][G] = cost[1][G]
dp[1][B] = cost[1][B]
```

result

```java
answer = min(dp[N][R], dp[N][G], dp[N][B])
```

[정수삼각형]

```java
dp[i][j] = (0,0)부터 (i,j)까지 내려왔을 때의 최대 합
```
```java
if(dp[i][0] = triangle[i][0] + dp[i-1][0]) //왼쪽 가장자리는 오른쪽 위만 가능
if(dp[i][i] = triangle[i][i] + dp[i-1][i-1]) //오른쪽 가장자리는 왼쪽 위만 가능
dp[i][j] = triangle[i][j] + max(dp[i-1][j], dp[i-1][j-1]) //왼쪽 위, 오른쪽 위 경우의 수 중 큰 값 선택
```
