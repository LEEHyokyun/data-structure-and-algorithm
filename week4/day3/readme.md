## 1. Day3

[Char 연산]
- Implements : 배운점
  - 입력의 크기나 조합의 크기를 살펴보는 것이 좋을 듯
    - 백트래킹은 일단 알고있으면 좋을 것 같고, 기본적으로는 완전탐색(브루트포스)가 기본인듯하다.
  - 브루트포스
    - 무식한 반복
  - 백트래킹
    - 기저조건을 넣고 최적화한 순회 방식, 사실상 모든 반복이긴 하지만 간결하고 깔끔
      - if(num == 2){
        if(!result.contains(sum))
        result.add(sum);

            //기저조건 중요..num == 2 이상까지 재귀반복 시 시간초과
            return;
        }
      - 기저조건은 매우 중요하다, 불필요한 반복순회를 지속하면 시간 초과 오류가 발생한다.
    - dfs적용 = start
      - 최초 시작점을 i
      - 그 이후의 조합을 재귀로 찾는다.
      - 이 순회가 계속 이루어지므로 조합 시 다른 인덱스를 보장한다.
    - return -> ways..sum = 0일때마다 ways++
    - stream에서 toArray는 말 그대로 "배열형태"로 변환하는 것이지, ArrayList와는 상관이 없다.
- Improvements : 막혔던 지점 / 고민한 포인트
  - 브루트포스, 백트래킹의 유형 문제에 대해 슬슬 감을 익혀야 한다.  
  - 조합문제를 마주하였을때의 마음가짐
    - “n개 중 k개 뽑기”의 경우의 수가 얼마나 되는지 예상해본다 — 만약 nCk가 너무 크면 단순 브루트포스는 안 되고 효율화 필요.
    - 순서가 중요한지 / 아닌지 명확히 구분 — 순서 상관 없으면 i<j<k 식으로 인덱스 제약 둬야 중복 제거 가능.
    - 조건 검사 로직 단순성 — 합, 곱, 특정 속성 여부 등 간단할수록 브루트포스도 충분할 수 있음.
- Additional : 추가적인 유의점들

[set -> int array]

set.stream().sorted().mapToInt(Integer::intValue).toArray();

[set -> Integer array]

Integer[] arr = set.toArray(new Integer[0]);

(Vanilla)
- int[] arr = new int[set.size()];
- int idx = 0;
- for (int v : set) arr[idx++] = v;

[set -> arrayList]

List<Integer> list = new ArrayList<>(set);

- List<Integer> list = new ArrayList<>(set);
- Collections.sort(list);

- List<Integer> list = set.stream().sorted().toList();

[set -> list -> int array]

- List<Integer> list = new ArrayList<>(set);
- Collections.sort(list);
- return list.stream().mapToInt(Integer::intValue).toArray();


[브루트포스 > 재귀(백트래킹) > 정렬/투포인터]

- 배열 크기가 작고, “3개 뽑아서 합이 0인지”라는 조건이 단순하므로 → 다중 for-loop 방식이 가장 간단하고 직관적.
- 만약 “3개뿐 아니라 k개, 조건이 더 복잡”한 변형이 생긴다면 → 백트래킹(재귀) 방식이 유연하다.
- 조건이 “합 = 0”처럼 정렬 + 탐색으로 최적화 여지가 있다면 → 정렬 + 포인터 방식도 고려 가능.

[조합을 접근하는 방법은 크게 3가지가 존재한다]
- 브루트포스(완전탐색)
- 재귀/백트래킹
- 정렬/투포인터

| 접근 방식                          | 동작 원리                                                                                                                                  | 문제키워드(힌트)                                                                                                          |                                                                                                                                                                                                          |
| ------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------ | -----------------------
| **1. 다중 중첩 반복문 (Brute Force)** | - 가능한 모든 경우를 직접 반복문으로 나열하여 탐색<br>- 주로 **i < j < k** 와 같이 인덱스 조건으로 **중복 조합 제거**<br>- n의 크기가 작을 때 매우 효과적                                 | - “배열 길이가 매우 작음 (N ≤ 15 정도)”<br>- "3개 뽑아라(고정된 개수)"<br>- "가능한 모든 조합/경우 확인"이라는 뉘앙스<br>- 시간 제한 느슨함                                | 
| **2. 백트래킹 (DFS 조합 생성)**        | - 재귀적으로 원소 선택/비선택을 결정하여 **조합(Subsets), 순열(Permutations)** 등을 만들어 탐색<br>- “가지치기(pruning)”로 불필요한 탐색 줄이기 가능<br>- n이 더 커질 때(20~30)에도 처리 가능 | - “모든 조합”, “모든 부분집합”, “모든 순열”<br>- “경우의 수가 많을 수 있음 (2^N, N!)”<br>- 뽑아야 하는 개수가 유동적 (k가 고정되지 않음)<br>- “탐색 중 특정 조건을 만족하면 중지/백트래킹” |
| **3. 정렬 + 투 포인터(Two Pointer)** | - 배열을 정렬한 뒤, 양쪽에서 좁혀오며 조건에 맞는 쌍/삼중을 찾음<br>- 주로 **합(sum)** 조건일 때 매우 강력<br>- 브루트포스보다 훨씬 빠름: O(N²) 또는 O(N)까지 가능                           | - “합이 0 되는 조합 찾기”<br>- “두 수의 합”, “세 수의 합”<br>- “정렬해서 효율적으로 찾을 수 있음”<br>- “연속 구간”, “부분합”, “최대/최소 간격”                            | 
