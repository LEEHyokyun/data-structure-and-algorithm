## 1. Day1

[이분탐색(Binary Search)]
- Implements : 배운점(문제)
  - 이분탐색 : 정방향
    - 톱날의 높이를 조절할때 높이가 클수록 잘리는 나무 수는 적어지고, 높이가 작을수록 잘리는 나무 수는 커진다.
    - 이에 따라 높이 조절의 방향(클수록 false, 작을수록 true)이 정해지는 단조의 성질이다.
      - 가능한 H 중에 반환값이 가장 큰 상황을 결정한다.
        - mid(톱날 높이)를 높이면: 잘리는 양 ↓ 감소 
        - mid를 낮추면: 잘리는 양 ↑ 증가
    - 다음 순회(low = mid + 1 or high = mid - 1)를 진행하면서 다음의 최적값이 나온다면 교체
      - 문제에서 구하고자 하는 값은 "톱날의 최대 길이"이므로 순회는 필요
      - 이 순회를 "이분탐색"으로 하는 것.
  - 이분탐색2 : 거꾸로
  - 특정 시간 T동안에
    - 각 심사관은 T/times[i] 처리 가능
    - 전체가능한 심사 수 = 모든 T/time[i]의 합
    - 만약 합이 n을 같거나 넘기면 가능
    - T의 단조가 보인다(불가능 > 불가능 > ... > 가능)
    - 이 순간을 탐색한다 = 이분탐색.
    - 시간의 범위를 주어지고, 이를 기준으로 탐색하는 것이 핵심.
      - 1 ~ max값*n
      - 이 시간을 이분탐색을 통해 순회하면서 가능한 최대명수(최소시간)을 구하는 것이 핵심(역으로 접근)
- Improvements : 작동원리/개선포인트(본질)
  - 크기에 대한 본질
    - 크기가 작으면 ? -> int
    - 크기가 크면 ? -> long 
  - 이분탐색의 작동원리
    - 탐색의 범위를 절반씩 줄여가면서 진행한다.
      - 내부 요소가 정렬되어 있거나
      - 어떤 값 x에 대해, 조건이 참 → 거짓 혹은 거짓 → 참 으로 한 방향으로만 바뀌어야 한다(이 단조가 정렬의 의미를 내포한다).
  - 이분탐색의 반대 개념이 바로 "완전탐색", 즉 brute force이다.
- Additional : 추가적인 유의점들

[key points]
이분탐색 = 정렬된 상태 = 단조

```java
while (low <= high):
mid = (low + high) / 2

    if mid가 조건을 만족한다면:
         → 더 좋은 답을 위해 범위를 좁힌다
    else:
         → mid는 답이 아니므로 범위를 다른 쪽으로 좁힌다
```
