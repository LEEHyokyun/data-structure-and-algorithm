## 1.  개요
> Study
- 본 프로젝트는 자료구조에 대한 이해와 알고리즘 구현 방안에 대해 학습한 내용을 담고있다.

> Computer Science
- 단순 자료구조 및 알고리즘에 대한 학습을 넘어, CS기반을 함양하고 구현방식에 대해 이해하면서 실무적으로 적용하기 위한 역량을 향상한다.
- 아키텍칭(설계)적인 부분과 함께 구현/전략구체화 시 응용가능한 방안들을 고민하면서 기록한다.

## 2. 자료구조와 알고리즘

> 프로그램의 본질적 의미이자, 문제를 해결하는 과정은
> - 어떤 자료구조를 활용하여
> - 어떤 알고리즘을 통해 
> 해를 도출할 것인가에 대한 과정이다.

> 자료구조는 데이터를 어떠한 구조로 어떻게 사용할 것인지에 대한 기본적인 방법이다.
- 변수와 배열도 하나의 자료구조이며, 어떠한 자료구조를 선택하느냐에 따라 구현방법 및 적용 알고리즘이 달라진다.

> 알고리즘은 문제에 대한 고민 부터 해결까지 일련의 서사를 모두 담고 있는 쳬계이자 과정이다.
- 중요한 것은 예외없이 특정 자료구조 및 데이터에 따라 확실하게 원하는 해를 도출해야 한다는 것.
- 변수 3개의 평균을 구하는 알고리즘과 변수 n개, 변수 n개에 대한 배열의 평균을 구하는 알고리즘은 다르다.

## 3. 시간복잡도

> 더 좋은 알고리즘은 사용자 요구에 따라 달라질 수 있지만, 보통은 처리속도를 성능의 척도로 간주한다.
- 이때 성능의 척도를 시간복잡도라 한다.

> 컴퓨터 사양마다 알고리즘의 실행 시간은 다를 수 있기에, 알고리즘의 실행시간이 아닌 알고리즘 실행시간(성능)에 영향을 줄 수 있는 부분을 찾아 실행시간을 예측한다.
- 이때 보통 반복문의 개수가 성능에 많은 영향을 준다.

> 빅오 표기법에 따른 시간복잡도 나타내기
- 특정 자료구조에 대한 알고리즘은 입력값이 늘어나거나 주어진 자료구조의 크기가 늘어남에 따라 그 성능척도가 달라질 수 있다.
- 최선의 경우를 Big-Omega, 최악의 경우를 Big-O, 평균의 경우를 Big-Theta로 표현하며 보통은 Big-O 표기법(최악의 경우)을 많이 활용한다.
- 입력크기에 비례하여 선형적으로 소요시간이 늘어나는 O(N), 입력에 상관없이 일정한 O(1) 등을 시작으로, O(logN), O(NlogN), O(N^2), O(2^N), O(N!) 등의 시간복잡도가 존재한다.
- Big-O 표기법의 경우 입력량에 따라 늘어나는 계산량을 최악의 경우로 표현한 것이고, 가장 영향을 많이 주는 척도 하나를 대표하여 표기한다.

## 4. 배열

> 읽기 : O(1), 쓰기 : O(N)
- 운영체제 측에선 최초 주소값을 기억하여 offset을 활용하여 데이터를 탐색하고 읽기에, 읽기(참조) 측면에서는 성능이 나쁘지 않다(배열크기 상관없이 O(1)의 시간복잡도를 지닌다).
- 크기를 미리 지정해두어야 하기에 메모리 공간적 효율이 좋지 않으며, 이후 데이터 쓰기 및 삭제작업이 별도로 이루어져 성능이 좋지 않다.

## 5. 연결리스트

> 읽기 : O(N), 쓰기 : O(N)
- 기존 배열의 메모리 연속적 할당과 크기 확장 등에 대한 단점을 보완하고자 도입된 자료구조이다.
- 과정적으로 노드의 데이터는 건드리지 않고 다음 포인터 주소만 변경하면 되기에 간단하지만, 이러한 데이터를 탐색하는 과정에서 순차적인 이동이 필요하여 O(N)의 선형복잡도를 가진다.
- 탐색작업이 오래 걸리기에 쓰기 작업의 시간 복잡도에도 영향을 주지만, 메모리 공간적 할당이나 절차적으로 보았을때는 기존 배열보다 더 간편하고 효율적이다.

## 6. 스택

> First In, Last Out
- 되돌리기를 위한 수행작업 임시 저장, 문법검사 등 여러 알고리즘에 사용 가능.

## 7. 큐

> First In, First Out
- head, tail을 사용하여 이중 연결리스트(양방향)을 활용해야 효과적 활용 가능(O(1)).
- 운영체제의 FIFO 스케쥴링 등 여러 알고리즘에서 사용 가능.

## Appendix. 알고리즘의 구현 전략

> 전략 #1. 단계적 접근
- 예외의 경우 혹은 동작이 불가능한 상황에 대한 고려
- 경계상황 등을 중심으로 동작분기처리
- 분기 상황 별 구현

> 전략 #2. 이전의 구현로직을 활용한다.
- 활용도가 높은 부분적 로직을 먼저 정의
- 예외의 경우 혹은 동작이 불가능한 상황에 대한 고려
- 경계상황 등을 중심으로 동작분기처리
- 분기 상황 별 구현
- 구현 후 이후 추가저인 로직 구현 시 이전의 구현로직을 최대환 활용한다.

## 이 외 유의하면 좋은 정보들

- String : 불변한 객체, 변수 로딩시 상수풀(Interned pool)에 저장된 불변 String 객체 지정, 동일 리터럴이면 재사용, 가장 빠르지만 상수 사용
- StringBuilder : 내부버퍼가 가변적(char[]), 내부 버퍼가 가득 차거나 append 시 다른 문자배열에 복사 후 교체, 내부구조 자체는 배열성격(연속된 할당공간/block), 데이터 쓰기작업이 어려운 대신 참조(읽기) 작업은 O(1).
- StringBuffer : StringBuilder와 유사하나 멀티 스레드의 동기처리를 보장하기 위한 synchronized 기반 동작에서 차이, 스레드 안전성, 단일 스레드 상황에선 그만큼의 오버헤드 발생.