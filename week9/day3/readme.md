## 1. Day3

[Sliding Window]

- 중복이 K개 이하로 이루어진 연속부분수열의 최대 길이
  - Arrays.sort/DP 등의 방향이 전혀 아니다.
  - "길이가 최대인 연속부분수열" .. "연속부분수열" -> "연속적인 배열의 길이"
    - 조건에 따른 길이의 조절 .. "슬라이딩 윈도우 적용"
    - 주어진 수열에서 조건에 맞는 부분수열을 도출하여야 하기에, 수열을 건드리면 안됨.
      - start = 0 , right 0 ~ N
        - 최초 cnt(빈도수) ++
        - 만약 빈도수가 K 초과하면? left ++ (=길이 감소효과)
        - 이에 대한 길이를 계속 누적/Math.max해가면서 비교

- 원형수열
  - 합은 중복되지 않기에, 결과를 담는 자료구조를 별도 생성
    - Set<Integer> result = new HashSet<>();
  - 슬라이딩 과정
    - 고정 길이 윈도우를 조절(=한칸씩 더하거나 한칸씩 빼는 과정).
      - 최초 길이 L의 윈도우 생성하고, "시작점"(=left)을 0~ N-1 인덱스로 이동하는 과정이 핵심.

[관건은 right, left의 조절]

- 빈도수를 체크해가면서 빈도가 높아지면 left++, cnt[value]--
- 길이의 변화가 중요, 최초 슬라이딩 윈도우 구성 후, 시작점을 0 ~ N-1지점으로 이동

```java
sum = sum - array[left] + array[right]
```

초기 윈도우를 먼저 설정하고

```java
//초기 윈도우
            for(int i = 0 ; i < length ; i++){
                sum += arr[i];
            }
            
            result.add(sum);
            
            
```

시작점을 옮긴다(슬라이딩 과정, 시작점은 1부터 N-1까지).

```java
//슬라이딩(=시작점 조절, )
            for(int start = 1 ; start < N ; start++){
                
            }
```

[빈도수를 따로 관리하는 아이디어]

```java
int[] cnt = new int[100001]; //숫자빈도관리 -> 숫자보다 커야함.
```