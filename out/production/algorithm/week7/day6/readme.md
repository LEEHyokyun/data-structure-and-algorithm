## 1. Day6

[Back Tracking/Brute Force]
- N Queen
  - row 당 한개의 퀸만 놓을 수 있다.
    - int[] col
      - index = row, cold = 해당 row에 체스를 놓을 열
      - 이를 활용하여 모든 경우에 대해 백트래킹 진행.
      - 최초 시작 : col[0]의 0 (row = 0에 col 0에 퀸 두는 것부터 시작)
        - 이후 col[0] = 0 -> 가능하면 row + 1, ..
- 던전 피로도
  - 부분의 해가 전체의 최적화로 이어지지 않으면 그냥 단순하게 완전탐색/브루트포스로 생각하자.
  - 완전탐색에는 힌트가 항상 존재한다.
    - 요소의 개수가 꽤나 작다 = 100만개 ~ 500만개? -> 브루트포스 의심(DFS/백트래킹은 "가지치기")
    - 그 이상이면 다른 방법

- static 변수를 활용하여 dfs 모두 종료 후 다른 순회까지 이용하고자 한다면
  - 지금과 같은 던전 및 NQueen
    - boolean과 같은 초기화 필요 요소 확인
      - //초기화 .. visited[i] = false;

[문제의 판단]
- 완전탐색/브루트포스/백트래킹
- 가지치기(DFS/백트래킹)
- 인접노드와의 관계 / 인접 좌표로의 이동 / 최단경로(BFS)
- 가중치 최단경로(다익스트라)
- 부분 최적 해(DP/그리디)

[Java 연산정도로 브루트포스의 힌트를 얻을 수 있다]
- 1초에 약 5천만 ~ 1억개 가능,
  - 이는 전체 경우의 수 * 내부 연산의 "소요시간"에 대한 지표로 활용한다.
- "완전탐색" "브루트포스"는 경우의 수를 보고 어느정도 힌트를 얻을 수 있다.
  - 전체 경우의 수가 100만개? -> 거의 무조건 브루트포스, 1000만개 이하? -> 브루트포스로 가능하지만 이외의 방법을 생각해보자.

- 브루트포스

| 경우의 수 | 판단          |
| ----- | ----------- |
| ≤ 10⁶ | **무조건 가능**  |
| ≤ 10⁷ | 대부분 가능      |
| ≤ 10⁸ | 빡빡 / C++ 유리 |
| ≥ 10⁹ | ❌ 불가능       |

- 가지치기/DFS/백트래킹

| 최대 상태 수 | 판단           |
| ------- | ------------ |
| ≤ 10⁵   | 매우 안전        |
| ≤ 10⁶   | 안전           |
| ≤ 10⁷   | 가능 (가지치기 필수) |
| ≥ 10⁸   | ❌ 위험         |

- DP/그리디
  - 부분 최적 해 = 전체의 최적 해
  - 기본적으로 기준에 대한 정렬이 필요하다.