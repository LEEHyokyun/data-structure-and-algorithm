## 1. Day3

[Stack/큐+우선순위큐]
- Implements : 배운점
  - 수열
    - 다음에 넣어야 할 숫자를 따로 두고, push는 언제든지 가능하다.
    - 중요한 점은 pop을 하는 시점에 다르다는 것은 stack의 top에 더 큰 값이 있다는 의미이므로 이 경우가 불가능한 경우.
      - Stack -> Stack
  - 프린터
    - 큐, 우선순위 큐 자료구조를 활용하여 우선순위가 가장 높다면 바로 인쇄, 후순위라면 인쇄하지 않고 큐의 마지막에 재배치
    - 큐 뿐만 아니라 우선순위 큐와 다같이 활용해야 한다는 점이 중요하였음.
      - Queue -> LinkedList
      - PriorityQueue -> PriortyQueue
- Improvements : 막혔던 지점 / 고민한 포인트
  - 문제의 유형을 어느정도 기억하는 것이 필요하다.  
    - 문제를 이해하는 것 부터가 시간이 오래 소요됨..많은 문제를 풀어보는 것이 중요한 것을 다시 한번 느낌
  - 각각의 자료구조와 자료구조가 제공하는 dsl api를 이해하고 있는가
  - 각각의 자료구조를 활용하여 적절한 구현을 해낼 수 있는가
    - 내부적인 로직은 자료구조를 적절히 활용하여 구현해야 했었다.
- Additional : 추가적인 유의점들

👉 문제를 자료구조 관점에서 바라보는 연습
“이 문제에서 필요한 동작이 무엇이고, 그걸 가장 자연스럽게 제공하는 자료구조가 무엇인가?”

'현재 최고 우선순위가 무엇인가' → PriorityQueue
'요청된 pop 순서가 가능할까?' → Stack
‘두 인덱스를 좁혀가며 스캔’ → 투포인터

LinkedListQueue는 “중간 삽입/삭제는 비효율적”이지만
“앞에서 꺼내고 뒤에 넣기”에는 매우 효율적(O(1))

PriorityQueue는 "정렬된 전체 리스트"가 아니라
"최댓값(또는 최솟값)만 빠르게 찾고 제거하는" 자료구조
출력 순서를 순서대로 유지하려면 Queue와 함께 사용해야 함.