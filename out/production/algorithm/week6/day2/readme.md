## 1. Day2

[백트래킹]
- Implements : 배운점(문제)
  - 기저조건 + 조건 만족 시 dfs로 다음 단계 진행
    - 역방향 연산을 진행하면서 조건을 만족하면 기저조건을 통해 true를 반환해준다.
      - T -> S, 역방향 연산 진행
        - 두 연산 중 가능한 연산은 모두 선택해서 DFS로 내려가 보고, S를 생성했다? 그러면  OK.
          - S -> T (X) T -> S (O)
            - S -> T 자체가 어떤 연산을 적용할 수 있을지, 가지치기가 너무 많다.
            - 정방향이 아닌 역방향 탐색이 필수적
      - 뒤의 dfs boolean 연산 중 하나라도 true라면 ? true 
        - | (OR) -> a |= b -> a = a | b
        - & (AND) -> a &= b -> a = a & b
    - 퀸(가로/세로/대각선)
      - 한 행에 퀸을 하나씩 놓을 수 있는 모든 가정을 탐색한다.
        - 한 행 안됨(가로) 한 열 안됨(세로) 대각선 안됨
          - 이 위치가 가능한가?
            - col + 대각선(규칙성)
              - row, col -> row마다 배치하고 col 및 대각선 길이의 적정성을 확인 이 두가지만 유효성 검증 필요
                - row: 현재 몇 번째 행까지 퀸을 배치했는가
                - col[i]: i번째 행에 퀸이 놓인 열 위치
                  - row, col[i]가 주어졌을때 인접노드를 탐색, 그 인접노드에 또 다른 퀸이 있으면 안됨
                  - row + 어느 col 선택 > row + 어느 col 선택 > .... 반복.
- Improvements : 작동원리/개선포인트(본질)
  - 대각선 검증? 
    - 예를 들어 (0,0)에서 대각선으로 갈 수 있는 곳은 1,1 2,2 3,3 4,4 ..
      - 행도 1 증가, 열도 1 증가
        행도 2 증가, 열도 2 증가
        ...
      - 동일 대각선이라면 같은 행, 같은 열만큼 이동
        - 따라서 행 offset = 열 offset.
  - /*
    * row = 0
    *   col = 0  -> dfs(1)  -> col = 2
    *                              -> dfs(2)  -> col = 0 ~ N-1 (위치 하고 그 이후에 row + 1...)
    *                                   ...
    *                       -> col = 3
    *   col = 1  -> ...
    */
- Additional : 추가적인 유의점들

[substring 정리]

- 구간형태(a, b) → “인덱스 a부터 b-1까지”
- 단독형태(a) → “인덱스 a번째 글자부터 끝까지”

| 규칙                                               | 설명      |
| ------------------------------------------------ | ------- |
| `substring(a, b)`는 **a ≤ x < b** 구간              | b는 포함 X |
| `substring(a)`는 **a부터 끝까지**                      |         |
| index는 **0부터 시작**                                |         |
| out-of-range → `StringIndexOutOfBoundsException` |         |

- 앞/뒤 문자 제거

| 목적                          | 코드                             | 설명(결과)          |
| --------------------------- | ------------------------------ | --------------- |
| **앞의 한 문자만 추출** (0번 인덱스 문자) | `s.substring(0, 1)`            | 앞의 한 문자만 가져옴    |
| **앞의 한 문자를 제거한 나머지 문자열**    | `s.substring(1)`               | 0번 인덱스를 제거한 문자열 |
| **뒤의 한 문자만 추출** (마지막 문자)    | `s.substring(s.length()-1)`    | 마지막 문자만 가져옴     |
| **뒤의 한 문자를 제거한 나머지 문자열**    | `s.substring(0, s.length()-1)` | 마지막 문자 제외한 문자열  |

- N글자 제거

| 목적                      | 코드                             | 설명        |
| ----------------------- | ------------------------------ | --------- |
| **앞의 N글자만 추출**          | `s.substring(0, N)`            | prefix 추출 |
| **앞의 N글자를 제거한 나머지 문자열** | `s.substring(N)`               | 앞에서 N개 제거 |
| **뒤의 N글자만 추출**          | `s.substring(s.length()-N)`    | suffix 추출 |
| **뒤의 N글자를 제거한 나머지 문자열** | `s.substring(0, s.length()-N)` | 뒤에서 N개 제거 |

- 특정 구간 slice

| 목적                      | 코드                                      | 설명                   |
| ----------------------- | --------------------------------------- | -------------------- |
| **i번째 글자만 추출**          | `s.substring(i, i+1)`                   | charAt(i)와 동일        |
| **i번째 ~ j번째-1 글자까지 추출** | `s.substring(i, j)`                     | `[i, j)` 구간, j는 포함 X |
| **중간 덩어리 잘라내기**         | `s.substring(left, s.length() - right)` | 양쪽 일정 길이 제거 후 중간 유지  |

- 특수패턴

| 목적                    | 코드                                                         | 설명                 |
| --------------------- | ---------------------------------------------------------- | ------------------ |
| **문자열 회전 (왼쪽으로 1칸)**  | `s.substring(1) + s.substring(0,1)`                        | 예: ABCD → BCDA     |
| **문자열 회전 (오른쪽으로 1칸)** | `s.substring(s.length()-1) + s.substring(0, s.length()-1)` | 예: ABCD → DABC     |
| **양쪽 괄호 제거**          | `s.substring(1, s.length()-1)`                             | (A[B]C) → A[B]C    |
| **중간 문자 제거**          | `s.substring(0, i) + s.substring(i+1)`                     | i번째 문자 삭제          |
| **2글자씩 자르기**          | `s.substring(i, i+2)`                                      | 문자열 토막내기 loop에서 활발 |
