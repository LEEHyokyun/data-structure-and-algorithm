## 1. Day5

[BFS]
- 모든 요소에 대해 BFS 진행
  - box[nx][ny] = box[x][y] + 1
  - 이전의 기간(경로)에서 값을 누적해가면서, 가장 늦게 익은 값을 추출한다.
- BFS를 종료한 후 -1이 남아있으면 -1(모두 익는 것은 불가)
- "노드간 연결관계"가 아닌 "좌표/좌표이동"
  - q -> int[]
  - graph -> int[][]
  - visited -> int[][]
- bfs의 전체경로 훑기를 판단하는 요소는 "0"(안익은 토마토), "-1"이 아니다.
- 구하고자 하는 값은 걸린 "일수"
  - max값의 -1
- 단어변환
  - 이동할 수 있는 좌표 - x축좌표 - String 변환 가능한 요소
    - 인접노드로의 이동 -> Queue<String>
    - 단계이동 -> Queue<Integer> 
      - 인접노드이동 및 단계이동(깊이)에 대한 이동을 각각 별도의 Queue를 만들어서 운용
      - 인접노드로 이동하였다면? depth.offer(cnt+1);
        - 이동가능성의 판별 -> "단순히 단어의 차이가 한 곳에서만 존재하는 경우"
          - for 순회를 통해 단어가 동일하지 않은 곳이 "1개"
            - 단어 일치성을 방향부여를 하지말고, 스칼라 접근!

[이외]
- 이중 반복문에서
  - inner 반복문 빠져나오는 경우 -> break
  - outer 반복문 모두 빠져나오는 경우 -> return;

[return]
- while 안에서 정답추출 후 바로 return answer
- while을 통과하지 못하면 "자연스럽게 해 추출 불가" return 0 -1...